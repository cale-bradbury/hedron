/**
 * wow this file was autogenerated by the shadertoy import wizard
 * I better have better info scattered throuout than this before I go live ;)
 */

const { THREE, postprocessing, glslify } = window.HEDRON.dependencies
const { EffectPass, SavePass, TextureEffect, Effect, BlendFunction } = postprocessing
const { Uniform, Texture } = THREE
const frag = glslify.file('./frag.glsl')

class ShadertoyEffect extends Effect {
    constructor({
        blendFunction = BlendFunction.NORMAL,
    } = {}) {
        super('ShadertoyEffect', frag, {
            blendFunction,
            uniforms: new Map([
                ['iTime', new Uniform(0)],
                ['iResolution', new Uniform(new THREE.Vector2(100, 100))],
                ['iMouse', new Uniform(new THREE.Vector2(0, 0))],
                ['iChannel0', new Uniform(Texture)],
            ]),
        })
    }
}

class ##SHADER_NAME## {

    initiatePostProcessing() {
        this.shadertoyEffect = new ShadertoyEffect()
        this.shadertoyPass = new EffectPass(null, this.shadertoyEffect)
        this.savePass = new SavePass();
        this.shadertoyEffect.uniforms.get('iChannel0').value = this.savePass.renderTarget.texture
        const textureEffect = new TextureEffect({
            texture: this.savePass.renderTarget.texture,
        })

        this.texturePass = new EffectPass(null, textureEffect)
        return [this.savePass, this.texturePass, this.shadertoyPass]
    }

    update({ params, elapsedTimeMs }) {
        this.shadertoyEffect.uniforms.get('iTime').value = elapsedTimeMs / 1000;
        this.shadertoyEffect.uniforms.get('iMouse').value.x = params.iMouseX;
        this.shadertoyEffect.uniforms.get('iMouse').value.y = params.iMouseY;
    }
}

/**  HEDRON TIP **
  Class must be exported as a default.
**/
module.exports = ##SHADER_NAME##
